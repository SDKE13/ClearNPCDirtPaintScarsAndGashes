using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using nifly;
using Noggog;
using System.Text;
using Reloaded.Memory.Utilities;
using Mutagen.Bethesda.Plugins.Binary.Parameters;
using System.Linq;

namespace ClearNPCDirtPaintScarsAndGashes
{
    public class Mods
    {
        public string modFilename { get; set; }
        public string modFilepath { get; set; }
        public Mods()
        {
            modFilename = string.Empty;
            modFilepath = string.Empty;
        }
    }
    public class ConfigSettings
    {
        public bool bRemoveDirt { get; set; }
        public bool bRemovePaint { get; set; }
        public bool bRemoveTattoo { get; set; }
        public bool bRemoveScarsGashes { get; set; }
        public bool bLogOnly { get; set; }
        public List<Mods> Mods { get; set; }


        public ConfigSettings()
        {
            bRemoveDirt = false;
            bRemovePaint = false;
            bRemoveScarsGashes = false;
            bRemoveTattoo = false;
            bLogOnly = false;
            Mods = new List<Mods>();
        }

        public bool SettingsValid()
        {
            return true;
        }
    }

    public class Program
    {
        
        static Lazy<ConfigSettings>? Settings = null;
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch, new PatcherPreferences()
                {
                    NoPatch = true,
                    ExclusionMods = new List<ModKey>() { ModKey.FromFileName("Synthesis.esp") }
                })
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "config.json",
                    out Settings
                )
                .SetTypicalOpen(GameRelease.SkyrimSE, "YourPatcher.esp")
                .Run(args);
        }
        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if(Settings is null)
            {
                Settings = new Lazy<ConfigSettings>();
            }

            foreach(var mod in Settings.Value.Mods)
            {
                if(string.IsNullOrWhiteSpace(mod.modFilename) || string.IsNullOrWhiteSpace(mod.modFilepath))
                {
                    return;
                }

                string babesEsp = mod.modFilename;
                string babesMeshPath = mod.modFilepath;

                System.Console.WriteLine($"Processing {babesEsp}");
                System.Console.WriteLine($"Path {babesMeshPath}");
                System.Console.WriteLine($"");
                ProcessMod(babesEsp, babesMeshPath, state, Settings.Value);
            }
        }

        private static bool ProcessMod(string modFilename, string modFilepath,  IPatcherState<ISkyrimMod, ISkyrimModGetter> state, ConfigSettings Settings )
        {
            string babesEsp = modFilename;
            string babesMeshPath = System.IO.Path.Combine(modFilepath, "meshes", "actors", "character", "FaceGenData", "FaceGeom", babesEsp);
            bool bModUpdated = false;            
            string babesEspPath = System.IO.Path.Combine(state.DataFolderPath, babesEsp);
            SkyrimMod? babesOverlay = null;

            try
            {
                babesOverlay = SkyrimMod.CreateFromBinary(babesEspPath, SkyrimRelease.SkyrimSE);
            }
            catch (Exception ex)
            {
                System.Console.WriteLine(ex.Source);
                System.Console.WriteLine(ex.Message);
                System.Console.WriteLine(ex.StackTrace);
                return false;
            }
            
            System.IO.Directory.CreateDirectory(System.IO.Path.Combine(babesMeshPath, "temp"));

            Dictionary<FormKey, List<ushort>> raceTintmasks = new Dictionary<FormKey, List<ushort>>();
            List<string> validScarsGashes = new List<string>() { "NoScar", "NoGash" };
            using (var cache = state.LoadOrder.PriorityOrder.ToImmutableLinkCache())
            {
                foreach (var tempNPC in babesOverlay.Npcs)
                {
                    var r = tempNPC.Race.Resolve(cache);

                    if (r == null)
                    {
                        continue;
                    }

                    System.Console.WriteLine($"{(tempNPC.Configuration.Flags.HasFlag(NpcConfiguration.Flag.Female) ? "Female" : "Male")}> {tempNPC.Name?.ToString() ?? string.Empty} :: {tempNPC.EditorID?.ToString() ?? string.Empty} | {tempNPC.FormKey.ToString()}");

                    if (Settings.bRemoveDirt || Settings.bRemovePaint)
                    {
                        if (!raceTintmasks.ContainsKey(r.FormKey))
                        {
                            var t = r.HeadData?.Female?.TintMasks ?? null;
                            if (t == null)
                            {
                                continue;
                            }

                            if (Settings.bRemoveDirt)
                            {
                                var dirtIndexs = t.Where(a => (a.MaskType ?? TintAssets.TintMaskType.None) == TintAssets.TintMaskType.Dirt).Select(s => s.Index ?? 0);
                                raceTintmasks.Add(r.FormKey, dirtIndexs.ToList<ushort>());
                                if (dirtIndexs.Count() > 0)
                                {
                                    System.Console.Write("Removed dirt: ");
                                    bModUpdated = true;
                                }
                            }
                            if (Settings.bRemovePaint)
                            {
                                var paintIndexs = t.Where(a => (a.MaskType ?? TintAssets.TintMaskType.None) == TintAssets.TintMaskType.Paint).Select(s => s.Index ?? 0);
                                raceTintmasks[r.FormKey].AddRange(paintIndexs.ToList<ushort>());
                                if (paintIndexs.Count() > 0)
                                {
                                    System.Console.Write("Removed paint: ");
                                    bModUpdated = true;
                                }
                            }
                            if (Settings.bRemoveTattoo)
                            {
                                var tattooIndexs = t.Where(a =>
                                {
                                    return (a.FileName?.ToString() ?? string.Empty).Contains("Tattoo", StringComparison.InvariantCultureIgnoreCase);
                                }).Select(s => s.Index ?? 0); ;
                                raceTintmasks[r.FormKey].AddRange(tattooIndexs.ToList<ushort>());
                                if (tattooIndexs.Count() > 0)
                                {
                                    System.Console.Write("Removed tattoo: ");
                                    bModUpdated = true;
                                }
                            }
                        }

                        foreach (var layer in tempNPC.TintLayers)
                        {
                            if (layer == null)
                            {
                                continue;
                            }
                            if (raceTintmasks[r.FormKey].Contains(layer.Index ?? 0))
                            {
                                layer.InterpolationValue = 0;
                            }
                        }
                    }

                    if (Settings.bRemoveScarsGashes)
                    {
                        bool bRemovedScars = false;

                        for (var i = tempNPC.HeadParts.Count - 1; i >= 0; i--)
                        {
                            var headPart = tempNPC.HeadParts[i];

                            if (headPart == null)
                            {
                                continue;
                            }

                            var getHeadPart = headPart.Resolve(cache);

                            if (getHeadPart == null)
                            {
                                continue;
                            }

                            if (getHeadPart.Type == Mutagen.Bethesda.Skyrim.HeadPart.TypeEnum.Scars &&
                                !validScarsGashes.Exists(s => (getHeadPart.Name?.ToString() ?? string.Empty).Contains(s, StringComparison.InvariantCultureIgnoreCase)))
                            {
                                tempNPC.HeadParts.Remove(headPart);
                                bRemovedScars = true;
                            }
                        }

                        string babesMeshFilename = $"{tempNPC.FormKey.ID:x8}.nif".ToUpper();
                        string nifPath = System.IO.Path.Combine(babesMeshPath, babesMeshFilename);
                        string newNifPath = System.IO.Path.Combine(babesMeshPath, "temp", babesMeshFilename);

                        if (System.IO.File.Exists(nifPath))
                        {
                            if (!Settings.bLogOnly)
                            {
                                RemoveScarsFromNif(nifPath, newNifPath);
                            }
                        }

                        if (bRemovedScars)
                        {
                            System.Console.Write("Removed scars: ");
                            bModUpdated = true;
                        }
                    }
                    System.Console.WriteLine(string.Empty);
                }
            }

            state.Dispose();

            if (!Settings.bLogOnly && bModUpdated)
            {
                System.Console.Write("Back up original file:");
                if (!BackUpOriginalMod(System.IO.Path.Combine(modFilepath, modFilename)))
                {
                    System.Console.WriteLine("> Save error, can not continue.");
                    return false;
                }
                System.Console.WriteLine("> Done");

                System.Console.Write("Saving mod:");

                try
                {
                    babesOverlay.WriteToBinary(babesEspPath,
                        new BinaryWriteParameters()
                        {
                            MastersListOrdering = new MastersListOrderingByLoadOrder(state.LoadOrder),
                            Parallel = new ParallelWriteParameters() { MaxDegreeOfParallelism = 2 },
                            FormIDUniqueness = FormIDUniquenessOption.Iterate
                        });

                    System.Console.WriteLine("> Done");

                    System.Console.WriteLine(string.Empty);
                    System.Console.WriteLine(string.Empty);

                    return true;
                }
                catch (Exception ex)
                {
                    System.Console.WriteLine(ex.Source);
                    System.Console.WriteLine(ex.Message);
                    System.Console.WriteLine(ex.StackTrace);

                    return false;
                }
            }

            return false;
        }

        private static bool BackUpOriginalMod(string OriginalModPath)
        {
            string modFilename = System.IO.Path.GetFileName(OriginalModPath);
            string modPath = System.IO.Path.GetDirectoryName(OriginalModPath) ?? string.Empty;
            string dateSuffix = DateTime.Now.ToString("yyyyMMddhhmmss");
            string backSuffix = "_bak";
            string backUpFilename = $"{modFilename}{backSuffix}_{dateSuffix}";

            try
            {
                System.IO.File.Copy(OriginalModPath, System.IO.Path.Combine(modPath, backUpFilename), false);
                GC.Collect();
                GC.WaitForPendingFinalizers();
            }
            catch (Exception ex)
            {
                System.Console.WriteLine("EXCEPTION!!");
                System.Console.WriteLine(ex?.Source ?? string.Empty);
                System.Console.WriteLine(ex?.Message ?? string.Empty);
                System.Console.WriteLine(ex?.StackTrace ?? string.Empty);
                return false;
            }

            return true;
        }

        private static bool RemoveScarsFromNif(string filePath, string newNifPath)
        {
            List<string> validScarsGashes = new List<string>() { "NoScar", "NoGash" };
            List<string> hasScarGash = new List<string>() { "Scar", "Gash" };

            using (nifly.NifFile nf = new NifFile())
            {
                nf.Load(filePath);
                bool doSave = false;
                var triShapes = nf.GetShapes();

                for (int i = triShapes.Count - 1; i >= 0; i--)
                {
                    var shape = triShapes[i];
                    string shapeName = shape.name?.get() ?? string.Empty;

                    if (string.IsNullOrWhiteSpace(shapeName))
                    {
                        continue;
                    }

                    if (hasScarGash.Exists(s => shapeName.Contains(s, StringComparison.InvariantCultureIgnoreCase)) &&
                        !validScarsGashes.Exists(s2 => shapeName.Contains(s2, StringComparison.InvariantCultureIgnoreCase)))
                    {
                        nf.DeleteShape(shape);
                        doSave = true;
                    }
                }

                if (doSave)
                {
                    nf.Save(newNifPath);
                    return true;
                }
            }

            return false;
        }
    }
}
