using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using nifly;
using Noggog;
using System.Text;
using Reloaded.Memory.Utilities;
using Mutagen.Bethesda.Plugins.Binary.Parameters;
using System.Linq;
using CommandLine;
using Serilog;
using Serilog.Sinks.File;
using Serilog.Sinks.SystemConsole;
using Serilog.Core;
using ClearNPCDirtPaintScarsAndGashes.Models;
using ClearNPCDirtPaintScarsAndGashes.Common;
using System.Collections.Generic;

namespace ClearNPCDirtPaintScarsAndGashes
{
    public class Mods
    {
        public string modFilename { get; set; }
        public string modFilepath { get; set; }
        public Mods()
        {
            modFilename = string.Empty;
            modFilepath = string.Empty;
        }
    }
    public class ConfigSettings
    {
        public bool bRemoveDirt { get; set; }
        public bool bRemovePaint { get; set; }
        public bool bRemoveTattoo { get; set; }
        public bool bRemoveScarsGashes { get; set; }
        public bool bLogOnly { get; set; }
        public List<Mods> Mods { get; set; }


        public ConfigSettings()
        {
            bRemoveDirt = false;
            bRemovePaint = false;
            bRemoveScarsGashes = false;
            bRemoveTattoo = false;
            bLogOnly = false;
            Mods = new List<Mods>();
        }

        public bool SettingsValid()
        {
            return true;
        }
    }

    public class Program
    {
        internal static Logger _logger;
        internal static LoggingLevelSwitch _logLevel;
        internal static DateTime timeStamp;
        static Lazy<ConfigSettings>? Settings = null;

        static Program()
        {
            timeStamp = DateTime.Now;
            _logLevel = new LoggingLevelSwitch();
            _logLevel.MinimumLevel = Serilog.Events.LogEventLevel.Verbose;

            _logger = new LoggerConfiguration()
                .WriteTo.Console(outputTemplate: "{Timestamp:yyyy-MM-dd hh:mm:ss } [{SourceContext}] [{Level:u3}] {Message:lj}{NewLine}{Exception}")
                .WriteTo.File(path: $"log_{timeStamp.ToString("yyyyMMddhhmmss")}.txt", 
                    outputTemplate: "{Timestamp:yyyy-MM-dd hh:mm:ss} [{SourceContext}] [{Level:u3}] {Message:lj}{NewLine}{Exception}")
                .MinimumLevel.ControlledBy(_logLevel)                    
                .CreateLogger();
            _logger = (Logger)_logger.ForContext<Program>();
        }
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch, new PatcherPreferences()
                {
                    NoPatch = true,
                    ExclusionMods = new List<ModKey>() { ModKey.FromFileName("Synthesis.esp") }
                })
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "config.json",
                    out Settings
                )
                .SetTypicalOpen(GameRelease.SkyrimSE, "YourPatcher.esp")
                .Run(args);
        }
        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if(Settings is null)
            {
                Settings = new Lazy<ConfigSettings>();
            }

            foreach(var mod in Settings.Value.Mods)
            {
                if(string.IsNullOrWhiteSpace(mod.modFilename) || string.IsNullOrWhiteSpace(mod.modFilepath))
                {
                    return;
                }

                string babesEsp = mod.modFilename;
                string babesMeshPath = mod.modFilepath;

                _logger.Verbose($"Processing {babesEsp}");
                _logger.Verbose($"Path {babesMeshPath}");
                if(Settings.Value.bLogOnly)
                {
                    _logger.Verbose($"Patcher set to LogOnly");   
                }
                _logger.Verbose($"");
                ProcessMod(babesEsp, babesMeshPath, state, Settings.Value);
            }    
            
        }

        private static bool ProcessMod(string modFilename, string modFilepath,  IPatcherState<ISkyrimMod, ISkyrimModGetter> state, ConfigSettings Settings )
        {
            string babesEsp = modFilename;
            string babesMeshPath = System.IO.Path.Combine(modFilepath, "meshes", "actors", "character", "FaceGenData", "FaceGeom", babesEsp);
            bool bModUpdated = false;            
            string babesEspPath = System.IO.Path.Combine(state.DataFolderPath, babesEsp);
            SkyrimMod? babesOverlay = null;

            try
            {
                babesOverlay = SkyrimMod.CreateFromBinary(babesEspPath, SkyrimRelease.SkyrimSE);
                RemoveCompressionFlags(babesOverlay);

            }
            catch (Exception ex)
            {
                _logger.Error("EXCEPTION!!", ex);
                
                return false;
            }
            
            System.IO.Directory.CreateDirectory(System.IO.Path.Combine(babesMeshPath, "temp"));

            Dictionary<FormKey, RaceTintMask> raceTintmasks = new Dictionary<FormKey, RaceTintMask>();
            RaceTintMask? raceMask;
            int tempCount;

            List<string> validScarsGashes = new List<string>() { "NoScar", "NoGash" };
            using (var cache = state.LoadOrder.PriorityOrder.ToImmutableLinkCache())
            {
                foreach (var tempNPC in babesOverlay.Npcs)
                {
                    StringBuilder sbRemoved = new StringBuilder();
                    sbRemoved.Clear();

                    if(tempNPC.SkyrimMajorRecordFlags.HasFlag(SkyrimMajorRecord.SkyrimMajorRecordFlag.Deleted))
                    {
                        _logger.Verbose($"{(tempNPC.Configuration.Flags.HasFlag(NpcConfiguration.Flag.Female) ? "Female" : "Male")}> {tempNPC.Name?.ToString() ?? string.Empty} :: {tempNPC.EditorID?.ToString() ?? string.Empty} | {tempNPC.FormKey.ToString()}");
                        _logger.Verbose($"Has Deleted flag");
                        continue;
                    }
                    var r = tempNPC.Race.Resolve(cache);

                    if (r == null)
                    {
                        continue;
                    }

                    _logger.Verbose($"{(tempNPC.Configuration.Flags.HasFlag(NpcConfiguration.Flag.Female) ? "Female" : "Male")}> {tempNPC.Name?.ToString() ?? string.Empty} :: {tempNPC.EditorID?.ToString() ?? string.Empty} | {tempNPC.FormKey.ToString()}");

                    if(!raceTintmasks.TryGetValue(r.FormKey, out raceMask))
                    {
                        raceMask = new RaceTintMask(r);
                        raceTintmasks.Add(r.FormKey, raceMask);

                    }

                    Dictionary<TintType, List<ushort>> genderTintMasks;

                    if (tempNPC.Configuration.Flags.HasFlag(NpcConfiguration.Flag.Female))
                    {
                        genderTintMasks = raceMask.femaleRaceTintmasks;
                    }
                    else
                    {
                        genderTintMasks = raceMask.maleRaceTintmasks;
                    }

                    if(Settings.bRemoveDirt)
                    {
                        tempCount = tempNPC.TintLayers.Count;

                        tempNPC.TintLayers.RemoveWhere(rm =>
                        {
                            return genderTintMasks[TintType.Dirt].Contains(rm.Index ?? 0);
                        });
                     
                        if(tempCount != tempNPC.TintLayers.Count)
                        {
                            bModUpdated = true;
                            sbRemoved.Append("Removed dirt: ");
                        }
                    }

                    if (Settings.bRemovePaint)
                    {
                        tempCount = tempNPC.TintLayers.Count;

                        tempNPC.TintLayers.RemoveWhere(rm =>
                        {
                            return genderTintMasks[TintType.Paint].Contains(rm.Index ?? 0);
                        });
                        if (tempCount != tempNPC.TintLayers.Count)
                        {
                            bModUpdated = true;
                            sbRemoved.Append("Removed paint: ");
                        }
                    }

                    if (Settings.bRemoveTattoo)
                    {
                        tempCount = tempNPC.TintLayers.Count;

                        tempNPC.TintLayers.RemoveWhere(rm =>
                        {
                            return genderTintMasks[TintType.Tattoo].Contains(rm.Index ?? 0);
                        });
                        if (tempCount != tempNPC.TintLayers.Count)
                        {
                            bModUpdated = true;
                            sbRemoved.Append("Removed tattoo: ");
                        }
                    }

                    if (Settings.bRemoveScarsGashes)
                    {
                        bool bRemovedScars = false;

                        for (var i = tempNPC.HeadParts.Count - 1; i >= 0; i--)
                        {
                            var headPart = tempNPC.HeadParts[i];

                            if (headPart == null)
                            {
                                continue;
                            }

                            var getHeadPart = headPart.Resolve(cache);

                            if (getHeadPart == null)
                            {
                                continue;
                            }

                            if (getHeadPart.Type == Mutagen.Bethesda.Skyrim.HeadPart.TypeEnum.Scars &&
                                !validScarsGashes.Exists(s => (getHeadPart.Name?.ToString() ?? string.Empty).Contains(s, StringComparison.InvariantCultureIgnoreCase)))
                            {
                                tempNPC.HeadParts.Remove(headPart);
                                bRemovedScars = true;
                            }
                        }

                        string babesMeshFilename = $"{tempNPC.FormKey.ID:x8}.nif".ToUpper();
                        string nifPath = System.IO.Path.Combine(babesMeshPath, babesMeshFilename);
                        string newNifPath = System.IO.Path.Combine(babesMeshPath, "temp", babesMeshFilename);

                        if (System.IO.File.Exists(nifPath))
                        {
                            if (!Settings.bLogOnly)
                            {
                                RemoveScarsFromNif(nifPath, newNifPath);
                            }
                        }

                        if (bRemovedScars)
                        {
                            sbRemoved.Append("Removed scars: ");
                            bModUpdated = true;
                        }
                    }
                    if (sbRemoved.Length > 0)
                    {
                        _logger.Verbose(sbRemoved.ToString());
                    }
                    _logger.Verbose(string.Empty);
                }
            }

            state.Dispose();

            StringBuilder logOutput = new StringBuilder();

            if (!Settings.bLogOnly && bModUpdated)
            {
                logOutput.Append("Back up original file:");
                if (!BackUpOriginalMod(System.IO.Path.Combine(modFilepath, modFilename)))
                {
                    logOutput.Append("> Save error, can not continue.");
                    _logger.Error(logOutput.ToString());
                    return false;
                }
                logOutput.Append("> Done");
                _logger.Verbose(logOutput.ToString());

                logOutput.Clear();
                logOutput.Append("Saving mod:");

                try
                {
                    babesOverlay.WriteToBinary(babesEspPath,
                        new BinaryWriteParameters()
                        {
                            MastersListOrdering = new MastersListOrderingByLoadOrder(state.LoadOrder),
                            Parallel = new ParallelWriteParameters() { MaxDegreeOfParallelism = 2 },
                            FormIDUniqueness = FormIDUniquenessOption.Iterate
                        });

                    logOutput.Append("> Done");

                    _logger.Verbose(logOutput.ToString());
                    _logger.Verbose(string.Empty);

                    return true;
                }
                catch (Exception ex)
                {
                    _logger.Error(ex, "EXCEPTION!!");                    
                    return false;
                }
            }
            else
            {
                if(!bModUpdated)
                {
                    _logger.Verbose($"Update skipped, no changes made");
                }
                else
                {
                    _logger.Verbose($"Update skipped, mod set to LogOnly");
                }
                
                return true;
            }

            return false;
        }

        private static bool BackUpOriginalMod(string OriginalModPath)
        {
            string modFilename = System.IO.Path.GetFileName(OriginalModPath);
            string modPath = System.IO.Path.GetDirectoryName(OriginalModPath) ?? string.Empty;
            string dateSuffix = timeStamp.ToString("yyyyMMddhhmmss");
            string backSuffix = "_bak";
            string backUpFilename = $"{modFilename}{backSuffix}_{dateSuffix}";

            try
            {
                System.IO.File.Copy(OriginalModPath, System.IO.Path.Combine(modPath, backUpFilename), false);
                GC.Collect();
                GC.WaitForPendingFinalizers();
            }
            catch (Exception ex)
            {
                _logger.Error("EXCEPTION!!", ex);
                
                return false;
            }

            return true;
        }

        private static bool RemoveScarsFromNif(string filePath, string newNifPath)
        {
            List<string> validScarsGashes = new List<string>() { "NoScar", "NoGash" };
            List<string> hasScarGash = new List<string>() { "Scar", "Gash" };

            using (nifly.NifFile nf = new NifFile())
            {
                nf.Load(filePath);
                bool doSave = false;
                var triShapes = nf.GetShapes();

                for (int i = triShapes.Count - 1; i >= 0; i--)
                {
                    var shape = triShapes[i];
                    string shapeName = shape.name?.get() ?? string.Empty;

                    if (string.IsNullOrWhiteSpace(shapeName))
                    {
                        continue;
                    }

                    if (hasScarGash.Exists(s => shapeName.Contains(s, StringComparison.InvariantCultureIgnoreCase)) &&
                        !validScarsGashes.Exists(s2 => shapeName.Contains(s2, StringComparison.InvariantCultureIgnoreCase)))
                    {
                        bool isHair = false;

                        if (shape.HasSkinInstance())
                        {                            
                            var skinInstanceRef = shape.SkinInstanceRef();
                            //NiSkinInstance? nsi = nf.GetHeader()?.GetBlockById(skinInstanceRef.index) as NiSkinInstance;
                            //if (nsi != null)
                            //{
                                
                            //}

                            BSDismemberSkinInstance? bdsi = nf.GetHeader()?.GetBlockById(skinInstanceRef.index) as BSDismemberSkinInstance;                            
                            
                            if (bdsi != null)
                            {
                              isHair = true;                                
                            }
                        }

                        if (!isHair)
                        {
                            nf.DeleteShape(shape);
                            doSave = true;
                        }
                    }
                }

                if (doSave)
                {
                    nf.Save(newNifPath);
                    return true;
                }
            }

            return false;
        }

        static internal void RemoveCompressionFlags(SkyrimMod overLay)
        {
            int count = 0;

            foreach(var record in overLay.EnumerateMajorRecords())
            {
                if (record.IsCompressed)
                {
                    count += 1;
                    record.IsCompressed = false;
                    _logger.Verbose($"{record.EditorID?.ToString() ?? string.Empty} is compressed");
                }
            }
        }

      
    }
}
